//! Cross-validation tests using real coverage data generated by `cargo-llvm-cov`
//! on the covrs project itself. Both LCOV and Cobertura fixtures come from the
//! same test run, so their data should be consistent.

mod common;

use std::collections::{HashMap, HashSet};

static LCOV_BYTES: &[u8] = include_bytes!("fixtures/selfcov.lcov");
static COBERTURA_BYTES: &[u8] = include_bytes!("fixtures/selfcov_cobertura.xml");

fn parse_both() -> (covrs::model::CoverageData, covrs::model::CoverageData) {
    let lcov = covrs::parsers::lcov::parse(LCOV_BYTES).expect("failed to parse selfcov LCOV");
    let cobr = covrs::parsers::cobertura::parse(COBERTURA_BYTES)
        .expect("failed to parse selfcov Cobertura");
    (lcov, cobr)
}

// ── Parser-level cross-validation ──────────────────────────────────────────

#[test]
fn both_formats_parse_successfully() {
    let (lcov, cobr) = parse_both();
    assert!(!lcov.files.is_empty(), "LCOV should have files");
    assert!(!cobr.files.is_empty(), "Cobertura should have files");
}

#[test]
fn same_source_files() {
    let (lcov, cobr) = parse_both();

    let lcov_files: HashSet<&str> = lcov.files.iter().map(|f| f.path.as_str()).collect();
    let cobr_files: HashSet<&str> = cobr.files.iter().map(|f| f.path.as_str()).collect();

    assert_eq!(
        lcov_files,
        cobr_files,
        "LCOV and Cobertura should report the same set of source files\n  \
         only in LCOV: {:?}\n  only in Cobertura: {:?}",
        lcov_files.difference(&cobr_files).collect::<Vec<_>>(),
        cobr_files.difference(&lcov_files).collect::<Vec<_>>(),
    );
}

#[test]
fn same_line_counts_per_file() {
    let (lcov, cobr) = parse_both();

    let lcov_map: HashMap<&str, usize> = lcov
        .files
        .iter()
        .map(|f| (f.path.as_str(), f.lines.len()))
        .collect();

    for file in &cobr.files {
        let lcov_lines = lcov_map.get(file.path.as_str()).copied().unwrap_or(0);
        // Cobertura may have per-class entries that split a file, but llvm-cov
        // generates one class per file, so counts should match exactly.
        assert_eq!(
            file.lines.len(),
            lcov_lines,
            "Line count mismatch for {}: cobertura={}, lcov={}",
            file.path,
            file.lines.len(),
            lcov_lines,
        );
    }
}

#[test]
fn same_line_hit_counts_per_file() {
    let (lcov, cobr) = parse_both();

    // Build line-level maps: file -> line_number -> hit_count
    let lcov_map: HashMap<&str, HashMap<u32, u64>> = lcov
        .files
        .iter()
        .map(|f| {
            let lines: HashMap<u32, u64> = f
                .lines
                .iter()
                .map(|l| (l.line_number, l.hit_count))
                .collect();
            (f.path.as_str(), lines)
        })
        .collect();

    for file in &cobr.files {
        let lcov_lines = match lcov_map.get(file.path.as_str()) {
            Some(m) => m,
            None => continue, // covered by same_source_files test
        };

        for line in &file.lines {
            let lcov_hit = lcov_lines.get(&line.line_number).copied().unwrap_or(0);
            // llvm-cov may report slightly different execution counts between
            // formats due to inlining/dedup, but covered vs uncovered should agree.
            let cobr_covered = line.hit_count > 0;
            let lcov_covered = lcov_hit > 0;
            assert_eq!(
                cobr_covered, lcov_covered,
                "Coverage status mismatch for {}:{} — cobertura hit_count={}, lcov hit_count={}",
                file.path, line.line_number, line.hit_count, lcov_hit,
            );
        }
    }
}

#[test]
fn total_line_counts_match() {
    let (lcov, cobr) = parse_both();

    let lcov_total: usize = lcov.files.iter().map(|f| f.lines.len()).sum();
    let cobr_total: usize = cobr.files.iter().map(|f| f.lines.len()).sum();

    assert_eq!(
        lcov_total, cobr_total,
        "Total instrumentable lines should match: lcov={lcov_total}, cobertura={cobr_total}",
    );
}

// ── Database round-trip ────────────────────────────────────────────────────

#[test]
fn ingest_both_formats_and_compare_summaries() {
    // Ingest each format into its own DB and compare the summaries.
    let (lcov_data, cobr_data) = parse_both();

    let (mut conn_l, _dir_l, _) = common::setup_db();
    covrs::db::insert_coverage(&mut conn_l, "lcov", "lcov", None, &lcov_data, false).unwrap();
    let summary_l = covrs::db::get_summary(&conn_l).unwrap();

    let (mut conn_c, _dir_c, _) = common::setup_db();
    covrs::db::insert_coverage(&mut conn_c, "cobr", "cobertura", None, &cobr_data, false).unwrap();
    let summary_c = covrs::db::get_summary(&conn_c).unwrap();

    assert_eq!(
        summary_l.total_files, summary_c.total_files,
        "File count: lcov={}, cobertura={}",
        summary_l.total_files, summary_c.total_files,
    );
    assert_eq!(
        summary_l.total_lines, summary_c.total_lines,
        "Total lines: lcov={}, cobertura={}",
        summary_l.total_lines, summary_c.total_lines,
    );
    assert_eq!(
        summary_l.covered_lines, summary_c.covered_lines,
        "Covered lines: lcov={}, cobertura={}",
        summary_l.covered_lines, summary_c.covered_lines,
    );
}

#[test]
fn ingest_both_into_same_db_union_semantics() {
    // Ingesting both reports into one DB should not change line coverage
    // (same data, union = same result).
    let (lcov_data, cobr_data) = parse_both();

    let (mut conn, _dir, _) = common::setup_db();
    covrs::db::insert_coverage(&mut conn, "lcov", "lcov", None, &lcov_data, false).unwrap();
    let summary_single = covrs::db::get_summary(&conn).unwrap();

    covrs::db::insert_coverage(&mut conn, "cobr", "cobertura", None, &cobr_data, false).unwrap();
    let summary_both = covrs::db::get_summary(&conn).unwrap();

    // Total instrumentable lines shouldn't change (same files, same lines).
    assert_eq!(summary_single.total_lines, summary_both.total_lines);

    // Covered lines should stay the same (union of identical data).
    assert_eq!(summary_single.covered_lines, summary_both.covered_lines);

    // Reports list should show both.
    let reports = covrs::db::list_reports(&conn).unwrap();
    assert_eq!(reports.len(), 2);
}

#[test]
fn per_file_summaries_match_across_formats() {
    let (lcov_data, cobr_data) = parse_both();

    let (mut conn_l, _dir_l, _) = common::setup_db();
    covrs::db::insert_coverage(&mut conn_l, "lcov", "lcov", None, &lcov_data, false).unwrap();
    let files_l = covrs::db::get_file_summaries(&conn_l).unwrap();

    let (mut conn_c, _dir_c, _) = common::setup_db();
    covrs::db::insert_coverage(&mut conn_c, "cobr", "cobertura", None, &cobr_data, false).unwrap();
    let files_c = covrs::db::get_file_summaries(&conn_c).unwrap();

    let map_l: HashMap<&str, &covrs::model::FileSummary> =
        files_l.iter().map(|f| (f.path.as_str(), f)).collect();

    for fc in &files_c {
        let fl = map_l
            .get(fc.path.as_str())
            .unwrap_or_else(|| panic!("File {} in Cobertura but not LCOV DB", fc.path));
        assert_eq!(
            fl.total_lines, fc.total_lines,
            "{}: total_lines lcov={} cobr={}",
            fc.path, fl.total_lines, fc.total_lines,
        );
        assert_eq!(
            fl.covered_lines, fc.covered_lines,
            "{}: covered_lines lcov={} cobr={}",
            fc.path, fl.covered_lines, fc.covered_lines,
        );
    }
}

// ── Sanity checks on the data itself ───────────────────────────────────────

#[test]
fn coverage_rates_are_plausible() {
    let (lcov_data, _) = parse_both();

    let (mut conn, _dir, _) = common::setup_db();
    covrs::db::insert_coverage(&mut conn, "lcov", "lcov", None, &lcov_data, false).unwrap();
    let summary = covrs::db::get_summary(&conn).unwrap();

    // covrs should have decent but not 100% coverage of itself
    let rate = summary.line_rate();
    assert!(
        rate > 0.5,
        "Line coverage rate should be > 50%, got {:.1}%",
        rate * 100.0,
    );
    assert!(
        rate < 1.0,
        "Line coverage rate should be < 100% (we don't cover everything), got {:.1}%",
        rate * 100.0,
    );

    // Should have a reasonable number of files (the src/ directory)
    assert!(
        summary.total_files >= 8,
        "Expected at least 8 source files, got {}",
        summary.total_files,
    );
}
